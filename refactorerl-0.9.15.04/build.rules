%%% This file has -*- Erlang -*- syntax.

%% ===========================================================================
%% Configuration

%% These variables are used to generate the release file and boot script to
%% start RefactorErl. The startup script relies on the release name, so don't
%% change that. The version number should be updated when necessary.
RELEASE = "refactorerl".
VERSION = "0.9.12.04".

%% Flags used by the compiler
ErlFlags = [debug_info].

OTPRelease = erlang:system_info(otp_release).
OTPVersion = case string:to_integer(string:sub_string(OTPRelease, 1, 1)) of
                 {First, _} when is_integer(First) -> element(1, string:to_integer(OTPRelease));
                 _ -> element(1, string:to_integer(string:sub_string(OTPRelease, 2, 3)))
             end.

YawsIncDir = 
         begin 
             YawsEbin = os:getenv("YAWS_EBIN"),
             YawsApiHrlExternal = filename:join([YawsEbin, "../include/yaws_api.hrl"]),
             Result = case filelib:is_regular(YawsApiHrlExternal) of
                 true ->  CopiedIncDir = "lib/referl_ui/referl_yaws/include_mod",
                          file:make_dir(CopiedIncDir),
                          FC = element(2, file:read_file(YawsApiHrlExternal)), 
                          MC = binary:replace(FC, <<"-record(cookie">>, 
                             <<"%% The following definition has been modified by the RefactorErl" 
                             " builder for compatibility reasons (cookie->yaws_cookie):\n-record(yaws_cookie">>), 
                          file:write_file(filename:join([CopiedIncDir], "yaws_api.hrl"), MC),
                          CopiedIncDir;
                 false -> "lib/referl_ui/referl_yaws/include"
             end,
             Result
         end.

%% ===========================================================================
%% Description of targets
%%
%% tool    -- builds everything that is necessary to run the tool
%%              Included targets: builder
%%                                source
%%
%% doc     -- builds the API documentation
%%              Included targets: builder
%%                                source
%%
%% clean   -- removes every file that is generated by the build
%%
%% source  -- creates the complete source code, mainly by generating files
%%            which are to be generated
%%              Included targets: builder
%%
%% builder -- builds programs that are parts of the build system


%% ===========================================================================
%% Description of global rules
%%
%% erl  -- compiles and loads Erlang modules
%%           Input files: specified by #source.files
%%           Output dir: `ebin'
%%
%% yrl  -- generates Erlang code using yecc
%%           Input files: specified by #source.files
%%           Output dir: `src'
%%
%% xrl  -- generates Erlang code using leex
%%           Input files: specified by #source.files
%%           Output dir: `src'
%%
%% lex  -- generates a lexical analyser table using refgen_scanc
%%           Input files: specified by #source.files
%%           Output dir: `lex'
%%
%% app  -- generates application descriptors from .appspec files
%%           Input files: specified by #source.files
%%           Output dir: `ebin'
%%
%% rel  -- generates RELEASE.rel
%%           Input files: lib/*/ebin/*.app
%%           Output file: RELEASE.rel
%%
%% boot -- generates a boot script from a release file
%%           Input files: specified by #source.files (*.rel)
%%           Output dir: same as source
%%
%% doc  -- generated EDoc documentation for an application
%%           Input files: specified by #source.files (*.app)
%%           Output dir: `doc'
%%
%% eyrl  -- generates Erlang QC code using a generator generator
%%           Input files: specified by #source.files
%%           Output dir: `src'


%% ===========================================================================
%% Rules and targets

#rule{name   = erl,
      output = join("ebin", basename(File, ".erl")++".beam"),
      action =
        begin
            EtsLimit =
                case os:getenv("ERL_MAX_ETS_TABLES") of
                    false -> 1400;
                    String -> list_to_integer(String)
                end,
            OtpVersionMac =
                case OTPVersion < 15 of
                    true -> priorR15B;
                    false -> leastR15B
                end,
            EricssonMac =
                case os:getenv("ERICSSON") of
                    true -> [{d, ericsson, true}];
                    "true" -> [{d, ericsson, true}];
                    _ -> []
                end,
            IgraphMacro =
                case os:getenv("IGRAPH") of
                    true -> [{d, igraph, true}];
                    "true" -> [{d, igraph, true}];
                    _ -> []
                end,
            {ok, _} = compile:file(File, [report,
                                          {outdir, join(Dir, "ebin")},
                                          {i, join(Dir, "include")},
                                          {i, YawsIncDir},
                                          {d, {otpversion, OTPVersion}},
                                          {d, {ets_limit, EtsLimit}},
                                          {d, OtpVersionMac, true} |
                                          ErlFlags ++ EricssonMac ++ IgraphMacro]),
            code:purge(list_to_atom(basename(File, ".erl"))),
            code:load_abs(join([Dir, "ebin", basename(File, ".erl")]))
        end,
      deps    =
        begin
            Path = [join(Dir, "include") | [Inc || {i, Inc} <- ErlFlags]],
            [{file, F} || F <- referl_gen_build:erl_includes(File, Path)]
        end}.

#rule{name = c_src,
      output = 
        begin
            Name = basename(File),
            SharedLibraryFile = 
                case os:type() of
                    {win32, _} -> string:join([Name, ".dll"],"");
                    {unix, _}  -> string:join([Name, ".so"],"")
                end,
            join("priv", SharedLibraryFile)
        end,
      action = 
        begin
            CompileNif        = list_to_atom(os:getenv("COMPILE_CPP")),
            CCompiler       = os:getenv("C_COMPILER"),
            Name              = basename(File),
            BadmatchException = fun() -> 1 = 2 end,
            
            case {CompileNif, os:find_executable(CCompiler)} of
            %% Warnings; No compilation!
            {true, false} ->
                io:format("Warning: No C compiler found!~n" ++
                          "The C code of ~s has not been compiled!~n", [Name]);
            {false, _} ->
                io:format("Warning: the C code of ~s has not been compiled!~n",
                          [Name]);

            %% If everything is ok, then compile.
            {true, _} ->
                CommonCppCompilerFlags = "-Wall -fPIC -O3",
                CppCompilerFlags  = 
                    case {os:type(), os:version()} of
                        {{unix, darwin}, _} ->
                            "-undefined dynamic_lookup -dynamiclib";
                        {{unix, sunos}, {5, Mi, _}} when Mi == 8; Mi == 9 ->
                            "-D__OLD_SOLARIS__ -shared";
                        _ ->
                            "-shared"
                    end ++ " " ++ CommonCppCompilerFlags,
                CSources        = join([File, "src", "*.c"]),
                CHeadersDir     = join([File, "include"]),
                ErlNifDirectory   = join([code:root_dir(), "usr", "include"]),
                SharedLibraryFile = 
                    case os:type() of
                        {win32, _} -> string:join([Name, ".dll"],"");
                        {unix , _} -> string:join([Name, ".so"],"")
                    end,
                SharedLibraryPath = join([Dir, "priv", SharedLibraryFile]),
                
                CompileCmd =
                    CCompiler ++ "  "++ CppCompilerFlags ++ " " ++
                    CSources  ++ " " ++
                    " -I " ++ CHeadersDir ++ " -I " ++ ErlNifDirectory ++
                    " -o " ++ SharedLibraryPath,

                io:format("Compile command:~n~s~n",[CompileCmd]),
                case os:cmd(CompileCmd) of
                    ""         -> ok;
                    MaybeError ->
                        case string:str(MaybeError, "error:") of
                            0 ->
                                io:format("Build ended with warning(s):~n~s",
                                          [MaybeError]),
                                ok;
                            _ ->
                                io:format("Build ended with error(s):~n~s",
                                          [MaybeError]),
                                BadmatchException()
                        end
                end
          end
        end,
      deps = 
        begin
            DepFiles =
                filelib:wildcard(join([File, "src", "*.c"])) ++
                filelib:wildcard(join([File, "include", "*.h"])),
            [{file, F} || F <- DepFiles]
        end}.

#rule{name = cpp_src,
      output = 
        begin
            Name = basename(File),
            SharedLibraryFile = 
                case os:type() of
                    {win32, _} -> string:join([Name, ".dll"],"");
                    {unix, _}  -> string:join([Name, ".so"],"")
                end,
            join("priv", SharedLibraryFile)
        end,
      action = 
        begin
            CompileNif        = list_to_atom(os:getenv("COMPILE_CPP")),
            CppCompiler       = os:getenv("CPP_COMPILER"),
            Name              = basename(File),
            BadmatchException = fun() -> 1 = 2 end,
            
            case {CompileNif, os:find_executable(CppCompiler)} of
            %% Warnings; No compilation!
            {true, false} ->
                io:format("Warning: No g++ compiler found!~n" ++
                          "The CPP code of ~s has not been compiled!~n", [Name]);
            {false, _} ->
                io:format("Warning: the CPP code of ~s has not been compiled!~n",
                          [Name]);

            %% If everything is ok, then compile.
            {true, _} ->
                CommonCppCompilerFlags = "-Wall -fPIC -O3",
                CppCompilerFlags  = 
                    case {os:type(), os:version()} of
                        {{unix, darwin}, _} ->
                            "-undefined dynamic_lookup -dynamiclib";
                        {{unix, sunos}, {5, Mi, _}} when Mi == 8; Mi == 9 ->
                            "-D__OLD_SOLARIS__ -shared";
                        _ ->
                            "-shared"
                    end ++ " " ++ CommonCppCompilerFlags,
                CppSources        = join([File, "src", "*.cpp"]),
                CppHeadersDir     = join([File, "include"]),
                ErlNifDirectory   = join([code:root_dir(), "usr", "include"]),
                SharedLibraryFile = 
                    case os:type() of
                        {win32, _} -> string:join([Name, ".dll"],"");
                        {unix , _} -> string:join([Name, ".so"],"")
                    end,
                SharedLibraryPath = join([Dir, "priv", SharedLibraryFile]),
                
                CompileCmd =
                    CppCompiler ++ " " ++ CppCompilerFlags ++ " " ++
                    CppSources  ++ " " ++
                    " -I " ++ CppHeadersDir ++ " -I " ++ ErlNifDirectory ++
                    " -o " ++ SharedLibraryPath,

                io:format("Compile command:~n~s~n",[CompileCmd]),
                case os:cmd(CompileCmd) of
                    ""         -> ok;
                    MaybeError ->
                        case string:str(MaybeError, "error:") of
                            0 ->
                                io:format("Build ended with warning(s):~n~ts",
                                          [MaybeError]),
                                ok;
                            _ ->
                                io:format("Build ended with error(s):~n~ts",
                                          [MaybeError]),
                                BadmatchException()
                        end
                end
          end
        end,
      deps = 
        begin
            DepFiles =
                filelib:wildcard(join([File, "src", "*.cpp"])) ++
                filelib:wildcard(join([File, "include", "*.h"])),
            [{file, F} || F <- DepFiles]
        end}.


#rule{name = igraph_src,
      output = 
        begin
            Name = basename(File),
            SharedLibraryFile = 
                case os:type() of
                    {win32, _} -> string:join([Name, ".dll"],"");
                    {unix, _}  -> string:join([Name, ".so"],"")
                end,
            join("priv", SharedLibraryFile)
        end,
      action = 
        begin
            CompileNif        = list_to_atom(os:getenv("COMPILE_CPP")),
            CppCompiler       = os:getenv("CPP_COMPILER"),
            Name              = basename(File),
            BadmatchException = fun() -> 1 = 2 end,
            IsIgraph =
                case os:getenv("IGRAPH") of
                    true -> true;
                    "true" -> true;
                    _ -> false
                end,
             SharedLibraryExtension = 
                case os:type() of
                    {win32, _} -> ".dll";
                    {unix, darwin} -> ".dylib";
                    {unix, _}  -> ".so"
                end,

            case {CompileNif, os:find_executable(CppCompiler), IsIgraph} of
            %% Warnings; No compilation!
            {true, false, _} ->
                io:format("Warning: No g++ compiler found!~n" ++
                          "The CPP code of ~s has not been compiled!~n", [Name]);
            {false, _, _} ->
                io:format("Warning: the CPP code of ~s has not been compiled!~n",
                          [Name]);
            {true, _, false} -> io:format("Igraph has not been compiled.~n");
            %% If everything is ok, then compile.
            {true, _, true} ->
                IgraphPath = os:getenv("IGRAPHPATH"),
                IgraphInclDir = IgraphPath++"/include/igraph",
                IgraphLibDir = IgraphPath++"/lib",
                LinkCommand =
                    case os:type() of
                        {win32, _} -> " -Wl,-rpath "++IgraphLibDir++" -Wl,--whole-archive "
                                        ++IgraphLibDir++"/*"++
                                        SharedLibraryExtension ++" -Wl,--no-whole-archive ";
                        {unix, darwin} -> " -Wl,-rpath "++IgraphLibDir++" -Wl,-all_load "
                                          ++IgraphLibDir++"/*"++
                                          SharedLibraryExtension ++" -Wl,-noall_load ";
                        {unix, _}  -> " -Wl,-rpath "++IgraphLibDir++" -Wl,--whole-archive "
                                        ++IgraphLibDir++"/*"++
                                        SharedLibraryExtension ++" -Wl,--no-whole-archive "
                    end,
                CommonCppCompilerFlags = "-Wall -fPIC -O3 ",
                CppCompilerFlags  = 
                    case {os:type(), os:version()} of
                        {{unix, darwin}, _} ->
                            "-undefined dynamic_lookup -dynamiclib";
                        {{unix, sunos}, {5, Mi, _}} when Mi == 8; Mi == 9 ->
                            "-D__OLD_SOLARIS__ -shared";
                        _ ->
                            "-shared"
                    end ++ " " ++ CommonCppCompilerFlags,
                CppSources        = join([File, "src", "*.cpp"]),
                CppHeadersDir     = join([File, "include"]),
                ErlNifDirectory   = join([code:root_dir(), "usr", "include"]),
                SharedLibraryFile = 
                    case os:type() of
                        {win32, _} -> string:join([Name, ".dll"],"");
                        {unix , _} -> string:join([Name, ".so"],"")
                    end,
                SharedLibraryPath = join([Dir, "priv", SharedLibraryFile]),

                CompileCmd =
                    CppCompiler ++ " " ++ CppCompilerFlags ++ " " ++
                    CppSources  ++ LinkCommand ++" -I" ++ CppHeadersDir ++ 
                    " -I" ++ ErlNifDirectory ++ " -I"++IgraphInclDir++
                    " -o " ++ SharedLibraryPath,

                io:format("Compile command:~n~s~n",[CompileCmd]),
                case os:cmd(CompileCmd) of
                    ""         -> ok;
                    MaybeError ->
                        case string:str(MaybeError, "error:") of
                            0 ->
                                io:format("Build ended with warning(s):~n~s",
                                          [MaybeError]),
                                ok;
                            _ ->
                                io:format("Build ended with error(s):~n~s",
                                          [MaybeError]),
                                BadmatchException()
                        end
                end
          end
        end,
      deps = 
        begin
            DepFiles =
                filelib:wildcard(join([File, "src", "*.cpp"])) ++
                filelib:wildcard(join([File, "include", "*.h"])),
            [{file, F} || F <- DepFiles]
        end}.

#rule{name = kyoto_minimal,
      output = 
	  begin
	      SOFile =
		  case {os:type(), erlang:system_info(wordsize)} of
		      {{win32, _}, 8} -> "kyoto_minimal_x64.dll";
		      {{win32, _}, 4} -> "kyoto_minimal.dll";
		      {{unix, _}, _} -> "kyoto_minimal.so"
		  end,
	      join(["priv", SOFile])
	  end,
      action =
	  begin
	      SOFile =
		  case os:type() of
		      {win32, _} -> "kyoto_minimal.dll";
		      {unix, _} -> "kyoto_minimal.so"
		  end,
	      SOPath = join([Dir, "priv", SOFile]),
	      CompileNif = list_to_atom(os:getenv("COMPILE_CPP")),
	      CppCompiler = os:getenv("CPP_COMPILER"),
	      
	      case {CompileNif, os:find_executable(CppCompiler)} of
		  {true, false} ->
		      io:format("Warning: No g++ compiler found!~n"
				"The CPP code of ~s has not been compiled!~n",
				[SOFile]);
		  {false, _} ->
                      % why displaying a warning if compilation is not requested?
		      ok;		      
		  {true, _} ->
		      Cmd = "g++ -Wall -fPIC -O3 " ++
			  case os:type() of
			      {unix, darwin} -> "-undefined dynamic_lookup -dynamiclib ";
			      _ -> "-shared "
			  end ++
			  " -I " ++ join([code:root_dir(), "usr", "include"]) ++
			  " -I " ++ join([Dir, "kyoto", "lib", "kyotocabinet-1.2.76"]) ++
			  " " ++ join([Dir, "kyoto", "src", "refdb_kyoto_minimal.c"]) ++
			  " " ++ join([Dir, "kyoto", "lib", "kyotocabinet-1.2.76/*.cc"]) ++
			  " -o " ++ SOPath,
		      Res =
			  case os:type() of
			      {unix, _} ->
				  io:format("~s~n",[Cmd]),
				  os:cmd(Cmd);
			      {win32, _} ->
				  windows
			  end,
		      case Res of
			  windows -> ok; % windows
			  "" -> ok;
			  MaybeError -> 
			      io:format("~ts~n",[MaybeError]),
			      case string:str(MaybeError, "error:") of
				  0 ->
				      io:format("Build ended with warning(s)!~n~n");
				  _ ->
				      io:format("Build ended with error(s)! aborting...~n~n"),
				      1 = 2 % this is funny :))
			      end
		      end
	      end
	  end,
      deps =
	  [{file, F} || F <- 
               filelib:wildcard(join([Dir, "kyoto", "lib", "kyotocabinet-1.2.76", "*.cc"])) ++
	       filelib:wildcard(join([Dir, "kyoto", "src", "*.c"]))]
      }.
      
#rule{name = dep_graph,
      output = 
	    begin
	      SOFile =
		  case os:type() of
		      {win32, _} -> "dep_graph.dll";
		      {unix, _} -> "dep_graph.so"
		  end,
	      join(["priv", SOFile])
	    end,
      action =
	    begin
	      SOFile =
		  case os:type() of
		      {win32, _} -> "dep_graph.dll";
		      {unix, _} -> "dep_graph.so"
		  end,
	      Name              = basename(File),
	      SOPath = join([Dir, "priv", SOFile]),
	      CompileNif = list_to_atom(os:getenv("COMPILE_CPP")),
	      CppCompiler = os:getenv("CPP_COMPILER"),
	      BadmatchException = fun() -> 1 = 2 end,
	      
	      case {CompileNif, os:find_executable(CppCompiler)} of
		  {true, false} ->
		      io:format("Warning: No g++ compiler found!~n"
				"The CPP code of ~s has not been compiled!~n",
				[SOFile]);
		  {false, _} ->
              io:format("Warning: the CPP code of ~p has not been compiled!~n",
                [Name]);		      
		  {true, _} ->
		      Cmd = CppCompiler ++ " " ++
			  case os:type() of
			      {unix, darwin} -> "-undefined dynamic_lookup -dynamiclib ";
			      _ -> "-shared "
			  end ++ "-Wall -fPIC -O3 " ++
			  join([Dir, "dep_graph", "src", "refusr_dep_graph.cpp"]) ++
			  " -I " ++ join([code:root_dir(), "usr", "include"]) ++
			  " -I " ++ join([Dir, "dep_graph", "lib", "lemon-1.3"]) ++
              " -I " ++ join([Dir, "dep_graph", "include"]) ++
			  " -o " ++ SOPath ++ " -pthread -std=c++11",
		      io:format("Compile command:~n~s~n",[Cmd]),
		      
		      case os:cmd(Cmd) of
                    ""         -> ok;
                    MaybeError ->
                        case string:str(MaybeError, "error:") of
                            0 ->
                                io:format("Build ended with warning(s):~n~ts",
                                          [MaybeError]),
                                ok;
                            _ ->
                                io:format("Build ended with error(s):~n~ts",
                                          [MaybeError]),
                                BadmatchException()
                        end
                end
	      end
	    end,
      deps =
	  [{file, F} || F <- 
               filelib:wildcard(join([Dir, "dep_graph", "lib", "lemon-1.3", "*.cc"])) ++
	       filelib:wildcard(join([Dir, "dep_graph", "src", "*.cpp"]))]
      }.

#rule{name   = nitrogen_site,
      output = join("ebin", basename(File, ".erl")++".beam"),
      action =
        begin
            {ok, _} = compile:file(File, [report,
                                          {outdir, join(Dir, "ebin")},
                                          {i, join(Dir, "include")},
                                          {i, join(Dir,"../apps")} |
                                          ErlFlags]),
            code:purge(list_to_atom(basename(File, ".erl"))),
            code:load_abs(join([Dir, "ebin", basename(File, ".erl")]))
        end,
      deps    =
        begin
            Path = [join(Dir, "include") | [Inc || {i, Inc} <- ErlFlags]],
            [{file, F} || F <- referl_gen_build:erl_includes(File, Path)]
        end}.

#rule{name   = yaws,
      output = join("ebin", basename(File, ".erl")++".beam"),
      action =
        begin
            Yaws189 = list_to_atom(os:getenv("YAWS189")),
            YMacro = case Yaws189 of
            true -> YMacro = yaws189;
            false -> YMacro = yaws190
            end,
            {ok, _} = compile:file(File, [report,
                                          {outdir, join(Dir, "ebin")},
                                          {i, join(Dir, "include")},
                                          {i, YawsIncDir},
                                          {d, YMacro, true},
                                          %Expand function definition forms of parameterized module
                                          {parse_transform, pmod_pt} |
                                          ErlFlags]),
            code:purge(list_to_atom(basename(File, ".erl"))),
            code:load_abs(join([Dir, "ebin", basename(File, ".erl")]))
        end,
      deps    =
        begin
            Path = [join(Dir, "include") | [Inc || {i, Inc} <- ErlFlags]],
            [{file, F} || F <- referl_gen_build:erl_includes(File, Path)]
        end}.
        
#rule{name   = eyrl,
      output = join("src", basename(File,".eyrl")++".erl"),
      action = {ok,_}=egg:file(File, [verbose]),
      deps   = [{mod, egg}]}.

#rule{name   = yrl,
      output = join("src", basename(File,".yrl")++".erl"),
      action = {ok,_}=yecc:file(File, [verbose]),
      deps   = [{mod, yecc}]}.

#rule{name   = xrl,
      output = join("src", basename(File,".xrl")++".erl"),
      action = {ok,_}=leex:file(File, [verbose]),
      deps   = [{mod, leex}]}.

#rule{name   = lex,
      output = join("priv", basename(File)++".tab"),
      action = ok=refgen_scanc:file(
                    File,
                    [{output, join([Dir, "priv", basename(File)++".tab"])}]),
      deps   = [{mod, refgen_scanc}]}.

#rule{name   = app,
      output = join("ebin", basename(File, ".appspec")++".app"),
      action = %% This could be put into a module.
        begin
            {ok, Spec} = file:consult(File),
            App =
                {application, list_to_atom(basename(Dir)),
                 lists:map(
                   fun
                       ({modSrc, Mods}) ->
                           {modules,
                            [list_to_atom(basename(Src, ".erl")) ||
                                Src <- lists:append(
                                         [filelib:wildcard(
                                            join(dirname(File), Mod)) ||
                                             Mod <- Mods])]};
                       (Other) -> Other
                   end,
                   Spec)},
            ok = file:write_file(
                   join([Dir, "ebin", basename(File, ".appspec")++".app"]),
                   [io_lib:print(App), ".\n"])
        end}.

#rule{name   = rel,
      output = RELEASE ++ ".rel",
      action = %% This could also be put into a module.
        begin
            Apps = [list_to_atom(basename(App, ".app")) ||
                       App <- filelib:wildcard(
                                join([Dir, "lib", "*", "ebin", "*.app"]))],
            AllApps =
                [begin
                     application:load(App),
                     {ok, Deps} = application:get_key(App, applications),
                     [App | Deps]
                 end || App <- Apps],
            AppInfo =
                [begin
                     application:load(App),
                     {ok, Vsn} = application:get_key(App, vsn),
                     {App, Vsn}
                 end || App <- lists:usort(lists:flatten(AllApps))],
            Rel = {release,
                   {RELEASE, VERSION},
                   {erts, erlang:system_info(version)},
                   AppInfo},
            ok = file:write_file(join(Dir, RELEASE ++ ".rel"),
                                 [io_lib:print(Rel), ".\n"])
        end,
      deps   = [{file, App} ||
                   App <- filelib:wildcard(
                            join([Dir, "lib", "*", "ebin", "*.app"]))]}.

#rule{name   = boot,
      output = join(dirname(File), basename(File, ".rel")++".boot"),
      action = ok=systools:make_script(
                    join(dirname(File), basename(File, ".rel")),
                    [no_module_tests])}.

#rule{name   = doc,
      output = [join("doc", "index.html") |
                [join("doc", basename(F, ".erl") ++ ".html") ||
                    F <- filelib:wildcard(join([Dir, "src", "*.erl"]))]],
      action = try 
		   EtsLimit =
		       case os:getenv("ERL_MAX_ETS_TABLES") of
			   false -> 1400;
			   String -> list_to_integer(String)
		       end,
		   edoc:application(list_to_atom(basename(File, ".app")), 
				    [{preprocess, true}, 
				     {macros, [{ets_limit, EtsLimit},
					       {otpversion, OTPVersion},
                                               {case OTPVersion < 15 of
                                                    true -> priorR15B;
                                                    false -> leastR15B
                                                end, true}]},
				     {includes, ["./lib/referl_cluster/include",
						 "./lib/referl_cluster/src",
						 "./lib/referl_core/include",
						 "./lib/referl_core/src",
						 "./lib/referl_gen/include",
						 "./lib/referl_gen/src",
						 "./lib/referl_lib/include",
						 "./lib/referl_lib/src",
						 "./lib/referl_qc/include",
						 "./lib/referl_qc/src",
						 "./lib/referl_slicer/include",
						 "./lib/referl_slicer/src",
						 "./lib/referl_test/include",
						 "./lib/referl_test/src",
						 "./lib/referl_ui/include",
						 "./lib/referl_ui/src",
						 "./lib/referl_user/include",
						 "./lib/referl_user/src",
						 YawsIncDir
						]}]) of
                   ok -> ok
               catch
                   exit:error -> erlang:error(edoc_error)
               end,
      deps   = [{file, join([Dir, "doc", "overview.edoc"])} |
                [{file, F} || F<-filelib:wildcard(join([Dir,"src","*.erl"]))]]}.

#rule{name = bufsrv,
      output = ["bin/BufferServer"],
      action = case list_to_atom(os:getenv("COMPILE_BUFSRV")) of
                    false -> io:format("BufferServer has not been compiled.~n");
                    true -> io:format("~ts~n",[os:cmd("cabal install --bindir=bin")])
               end,
      deps = 
        begin
            Paths = [join([Dir, "lib", "referl_ui", "bufsrv"]), 
                    join([Dir, "lib", "referl_ui", "bufsrv", "RefErl", "BufferServer"]),
                    join([Dir, "lib", "referl_ui", "bufsrv", "RefErl", "BufferServer", "Data"])],
            Files = [{file, join(Dir, "bufferserver.cabal")}]++
            [{file, F} || SDir <- Paths, F <- filelib:wildcard(join([SDir,"*.hs"]))],
            Files
        end}.

#rule{
	name = qt_gui,
	output = 
		begin
			["lib/referl_ui/qt/bin/RefErlQt"]
		end,
	action = 
		begin
           case os:type() of
                {win32, _} -> 
			        io:format("QtGui has not been compiled since you seem to be using Windows~n"),
                    ok;
                _          ->
			        Name = basename(File),
			        CompileQt = list_to_atom(os:getenv("COMPILE_QT")), %Environment variable, true or false
                    ErlangLibPath = code:root_dir() ++ "/lib/", %The full path of the Erlang libraries
                    {ok, ErlangLibs} = file:list_dir( ErlangLibPath ),
                    [ ErlInterfaceDir | _ ] = lists:filter( (fun(Elem) -> string:str(Elem, "erl_interface") =/= 0 end) , ErlangLibs ),
                    ErlInterfacePath = ErlangLibPath ++ ErlInterfaceDir, %Full path of the Erl Interface
                    os:putenv("ERL_INTERFACE", ErlInterfacePath), %Export the Erl Interface path as an environment variable for qmake
                    CppCompiler  = os:getenv("CPP_COMPILER"),
                    CppCompilerOk = os:find_executable(CppCompiler),
                    QtOk = os:find_executable("qmake"),
                    Qt4Ok = os:find_executable("qmake-qt4"),
                    case Qt4Ok of
                        false -> QMakeCommand = "qmake " ++ File ++ " -o QMakefile";
                        _ -> QMakeCommand = "qmake-qt4 " ++ File ++ " -o QMakefile"
                    end,
                    CompileCommand = "make -f QMakefile -j9",
		            CleanCommand = "make -f QMakefile clean",
                    case {CompileQt, ErlInterfacePath, CppCompilerOk, QtOk, Qt4Ok} of
			        	{false, _, _, _, _} -> 
			        		io:format("QtGui has not been compiled~n");
			        	{true, _ ,false, _, _} ->
			        		io:format("Warning: No g++ compiler found!~n");
                        {true, _, _, false, false} ->
                            io:format("Warning: No qmake was found!~n");
			        	{true, _, _, _, _} ->
			        	    io:format("~ts~n", [QMakeCommand]),
			        	    os:cmd(QMakeCommand),
			        	    io:format("~ts~n", [CompileCommand]),
			        	    CompileResult = os:cmd(CompileCommand),
			        	    io:format("~ts~n", [CompileResult]),
			        	    io:format("~ts~n", [CleanCommand]),
			        	    CleanResult = os:cmd(CleanCommand),
			        	    io:format("~ts~n", [CleanResult])
                    end,
                    ok
           end
		end,
	deps = []	
}.

#target{name=source,
        rules=[#invoke{target=builder}]}.

#target{name=tool,
        rules=[#invoke{target=source}]}.

#target{name=doc,
        rules=[#invoke{target=source}]}.

#invoke{dir="lib"}.

#target{name=tool,
        rules=[#source{rule=rel},
               #source{files="refactorerl.rel", rule=boot},
               #source{rule=bufsrv},
               #source{files="lib/referl_ui/qt/src/qt.pro", rule=qt_gui}]}.

#target{name=clean,
        rules=[#apply{files=["refactorerl.*", "build.deps", "bin/BufferServer", "dist", "QMakefile", "lib/referl_ui/referl_yaws/include_mod/*"],
                      action=file:delete(File)},
               exit(clear_deps)]}.
